import * as i0 from '@angular/core';
import { inject, ElementRef, NgZone, ChangeDetectorRef, effect, DestroyRef, signal, EventEmitter, Injector, Directive, Input, Output } from '@angular/core';
import { DragGesture, HoverGesture, MoveGesture, PinchGesture, ScrollGesture, WheelGesture } from '@use-gesture/vanilla';
import { assertInjector } from 'ngxtension/assert-injector';
import { createInjectionToken } from 'ngxtension/create-injection-token';
const [injectZonelessGesture, provideFn] = createInjectionToken(() => false);
function provideZonelessGesture() {
  return provideFn(true);
}
function createGesture(_key, gesture) {
  return function _injectGesture(handler, {
    injector,
    config = () => ({}),
    zoneless
  } = {}) {
    return assertInjector(_injectGesture, injector, () => {
      const zonelessGesture = injectZonelessGesture();
      const host = inject(ElementRef);
      const zone = inject(NgZone);
      const cdr = inject(ChangeDetectorRef);
      zoneless ??= zonelessGesture;
      const ngHandler = state => {
        return handler(Object.assign(state, {
          cdr
        }));
      };
      const gestureInstance = zoneless ? zone.runOutsideAngular(() => new gesture(host.nativeElement, ngHandler)) : new gesture(host.nativeElement, ngHandler);
      effect(() => {
        if (zoneless) {
          zone.runOutsideAngular(() => {
            // @ts-expect-error typescript knows what the config is but gestureInstance can also set config for multiple gestures
            gestureInstance.setConfig(config());
          });
        } else {
          // @ts-expect-error typescript knows what the config is but gestureInstance can also set config for multiple gestures
          gestureInstance.setConfig(config());
        }
      });
      inject(DestroyRef).onDestroy(gestureInstance.destroy.bind(gestureInstance));
    });
  };
}
const injectDrag = createGesture('drag', DragGesture);
let NgxDrag = /*#__PURE__*/(() => {
  class NgxDrag {
    constructor() {
      this.config = signal({});
      this.ngxDrag = new EventEmitter();
      this.injector = inject(Injector);
    }
    set _config(config) {
      this.config.set(config);
    }
    ngOnInit() {
      injectDrag(this.ngxDrag.emit.bind(this.ngxDrag), {
        injector: this.injector,
        zoneless: this.zoneless,
        config: this.config
      });
    }
    static {
      this.ɵfac = function NgxDrag_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || NgxDrag)();
      };
    }
    static {
      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({
        type: NgxDrag,
        selectors: [["", "ngxDrag", ""]],
        inputs: {
          _config: [0, "ngxDragConfig", "_config"],
          zoneless: [0, "ngxDragZoneless", "zoneless"]
        },
        outputs: {
          ngxDrag: "ngxDrag"
        }
      });
    }
  }
  return NgxDrag;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
const injectHover = createGesture('hover', HoverGesture);
let NgxHover = /*#__PURE__*/(() => {
  class NgxHover {
    constructor() {
      this.config = signal({});
      this.ngxHover = new EventEmitter();
      this.injector = inject(Injector);
    }
    set _config(config) {
      this.config.set(config);
    }
    ngOnInit() {
      injectHover(this.ngxHover.emit.bind(this.ngxHover), {
        injector: this.injector,
        zoneless: this.zoneless,
        config: this.config
      });
    }
    static {
      this.ɵfac = function NgxHover_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || NgxHover)();
      };
    }
    static {
      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({
        type: NgxHover,
        selectors: [["", "ngxHover", ""]],
        inputs: {
          _config: [0, "ngxHoverConfig", "_config"],
          zoneless: [0, "ngxHoverZoneless", "zoneless"]
        },
        outputs: {
          ngxHover: "ngxHover"
        }
      });
    }
  }
  return NgxHover;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
const injectMove = createGesture('move', MoveGesture);
let NgxMove = /*#__PURE__*/(() => {
  class NgxMove {
    constructor() {
      this.config = signal({});
      this.ngxMove = new EventEmitter();
      this.injector = inject(Injector);
    }
    set _config(config) {
      this.config.set(config);
    }
    ngOnInit() {
      injectMove(this.ngxMove.emit.bind(this.ngxMove), {
        injector: this.injector,
        zoneless: this.zoneless,
        config: this.config
      });
    }
    static {
      this.ɵfac = function NgxMove_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || NgxMove)();
      };
    }
    static {
      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({
        type: NgxMove,
        selectors: [["", "ngxMove", ""]],
        inputs: {
          _config: [0, "ngxMoveConfig", "_config"],
          zoneless: [0, "ngxMoveZoneless", "zoneless"]
        },
        outputs: {
          ngxMove: "ngxMove"
        }
      });
    }
  }
  return NgxMove;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
const injectPinch = createGesture('pinch', PinchGesture);
let NgxPinch = /*#__PURE__*/(() => {
  class NgxPinch {
    constructor() {
      this.config = signal({});
      this.ngxPinch = new EventEmitter();
      this.injector = inject(Injector);
    }
    set _config(config) {
      this.config.set(config);
    }
    ngOnInit() {
      injectPinch(this.ngxPinch.emit.bind(this.ngxPinch), {
        injector: this.injector,
        zoneless: this.zoneless,
        config: this.config
      });
    }
    static {
      this.ɵfac = function NgxPinch_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || NgxPinch)();
      };
    }
    static {
      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({
        type: NgxPinch,
        selectors: [["", "ngxPinch", ""]],
        inputs: {
          _config: [0, "ngxPinchConfig", "_config"],
          zoneless: [0, "ngxPinchZoneless", "zoneless"]
        },
        outputs: {
          ngxPinch: "ngxPinch"
        }
      });
    }
  }
  return NgxPinch;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
const injectScroll = createGesture('scroll', ScrollGesture);
let NgxScroll = /*#__PURE__*/(() => {
  class NgxScroll {
    constructor() {
      this.config = signal({});
      this.ngxScroll = new EventEmitter();
      this.injector = inject(Injector);
    }
    set _config(config) {
      this.config.set(config);
    }
    ngOnInit() {
      injectScroll(this.ngxScroll.emit.bind(this.ngxScroll), {
        injector: this.injector,
        zoneless: this.zoneless,
        config: this.config
      });
    }
    static {
      this.ɵfac = function NgxScroll_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || NgxScroll)();
      };
    }
    static {
      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({
        type: NgxScroll,
        selectors: [["", "ngxScroll", ""]],
        inputs: {
          _config: [0, "ngxScrollConfig", "_config"],
          zoneless: [0, "ngxScrollZoneless", "zoneless"]
        },
        outputs: {
          ngxScroll: "ngxScroll"
        }
      });
    }
  }
  return NgxScroll;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
const injectWheel = createGesture('wheel', WheelGesture);
let NgxWheel = /*#__PURE__*/(() => {
  class NgxWheel {
    constructor() {
      this.config = signal({});
      this.ngxWheel = new EventEmitter();
      this.injector = inject(Injector);
    }
    set _config(config) {
      this.config.set(config);
    }
    ngOnInit() {
      injectWheel(this.ngxWheel.emit.bind(this.ngxWheel), {
        injector: this.injector,
        zoneless: this.zoneless,
        config: this.config
      });
    }
    static {
      this.ɵfac = function NgxWheel_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || NgxWheel)();
      };
    }
    static {
      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({
        type: NgxWheel,
        selectors: [["", "ngxWheel", ""]],
        inputs: {
          _config: [0, "ngxWheelConfig", "_config"],
          zoneless: [0, "ngxWheelZoneless", "zoneless"]
        },
        outputs: {
          ngxWheel: "ngxWheel"
        }
      });
    }
  }
  return NgxWheel;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * Generated bundle index. Do not edit.
 */

export { NgxDrag, NgxHover, NgxMove, NgxPinch, NgxScroll, NgxWheel, injectDrag, injectHover, injectMove, injectPinch, injectScroll, injectWheel, injectZonelessGesture, provideZonelessGesture };
