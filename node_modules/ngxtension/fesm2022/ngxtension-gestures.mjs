import * as i0 from '@angular/core';
import { inject, ElementRef, NgZone, ChangeDetectorRef, effect, DestroyRef, signal, EventEmitter, Injector, Directive, Input, Output } from '@angular/core';
import { DragGesture, HoverGesture, MoveGesture, PinchGesture, ScrollGesture, WheelGesture } from '@use-gesture/vanilla';
import { assertInjector } from 'ngxtension/assert-injector';
import { createInjectionToken } from 'ngxtension/create-injection-token';

const [injectZonelessGesture, provideFn] = createInjectionToken(() => false);
function provideZonelessGesture() {
    return provideFn(true);
}

function createGesture(_key, gesture) {
    return function _injectGesture(handler, { injector, config = () => ({}), zoneless } = {}) {
        return assertInjector(_injectGesture, injector, () => {
            const zonelessGesture = injectZonelessGesture();
            const host = inject(ElementRef);
            const zone = inject(NgZone);
            const cdr = inject(ChangeDetectorRef);
            zoneless ??= zonelessGesture;
            const ngHandler = (state) => {
                return handler(Object.assign(state, { cdr }));
            };
            const gestureInstance = zoneless
                ? zone.runOutsideAngular(() => new gesture(host.nativeElement, ngHandler))
                : new gesture(host.nativeElement, ngHandler);
            effect(() => {
                if (zoneless) {
                    zone.runOutsideAngular(() => {
                        // @ts-expect-error typescript knows what the config is but gestureInstance can also set config for multiple gestures
                        gestureInstance.setConfig(config());
                    });
                }
                else {
                    // @ts-expect-error typescript knows what the config is but gestureInstance can also set config for multiple gestures
                    gestureInstance.setConfig(config());
                }
            });
            inject(DestroyRef).onDestroy(gestureInstance.destroy.bind(gestureInstance));
        });
    };
}

const injectDrag = createGesture('drag', DragGesture);
class NgxDrag {
    constructor() {
        this.config = signal({});
        this.ngxDrag = new EventEmitter();
        this.injector = inject(Injector);
    }
    set _config(config) {
        this.config.set(config);
    }
    ngOnInit() {
        injectDrag(this.ngxDrag.emit.bind(this.ngxDrag), {
            injector: this.injector,
            zoneless: this.zoneless,
            config: this.config,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxDrag, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.3", type: NgxDrag, isStandalone: true, selector: "[ngxDrag]", inputs: { _config: ["ngxDragConfig", "_config"], zoneless: ["ngxDragZoneless", "zoneless"] }, outputs: { ngxDrag: "ngxDrag" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxDrag, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngxDrag]',
                    standalone: true,
                }]
        }], propDecorators: { _config: [{
                type: Input,
                args: ['ngxDragConfig']
            }], zoneless: [{
                type: Input,
                args: ['ngxDragZoneless']
            }], ngxDrag: [{
                type: Output
            }] } });

const injectHover = createGesture('hover', HoverGesture);
class NgxHover {
    constructor() {
        this.config = signal({});
        this.ngxHover = new EventEmitter();
        this.injector = inject(Injector);
    }
    set _config(config) {
        this.config.set(config);
    }
    ngOnInit() {
        injectHover(this.ngxHover.emit.bind(this.ngxHover), {
            injector: this.injector,
            zoneless: this.zoneless,
            config: this.config,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxHover, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.3", type: NgxHover, isStandalone: true, selector: "[ngxHover]", inputs: { _config: ["ngxHoverConfig", "_config"], zoneless: ["ngxHoverZoneless", "zoneless"] }, outputs: { ngxHover: "ngxHover" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxHover, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngxHover]',
                    standalone: true,
                }]
        }], propDecorators: { _config: [{
                type: Input,
                args: ['ngxHoverConfig']
            }], zoneless: [{
                type: Input,
                args: ['ngxHoverZoneless']
            }], ngxHover: [{
                type: Output
            }] } });

const injectMove = createGesture('move', MoveGesture);
class NgxMove {
    constructor() {
        this.config = signal({});
        this.ngxMove = new EventEmitter();
        this.injector = inject(Injector);
    }
    set _config(config) {
        this.config.set(config);
    }
    ngOnInit() {
        injectMove(this.ngxMove.emit.bind(this.ngxMove), {
            injector: this.injector,
            zoneless: this.zoneless,
            config: this.config,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxMove, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.3", type: NgxMove, isStandalone: true, selector: "[ngxMove]", inputs: { _config: ["ngxMoveConfig", "_config"], zoneless: ["ngxMoveZoneless", "zoneless"] }, outputs: { ngxMove: "ngxMove" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxMove, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngxMove]',
                    standalone: true,
                }]
        }], propDecorators: { _config: [{
                type: Input,
                args: ['ngxMoveConfig']
            }], zoneless: [{
                type: Input,
                args: ['ngxMoveZoneless']
            }], ngxMove: [{
                type: Output
            }] } });

const injectPinch = createGesture('pinch', PinchGesture);
class NgxPinch {
    constructor() {
        this.config = signal({});
        this.ngxPinch = new EventEmitter();
        this.injector = inject(Injector);
    }
    set _config(config) {
        this.config.set(config);
    }
    ngOnInit() {
        injectPinch(this.ngxPinch.emit.bind(this.ngxPinch), {
            injector: this.injector,
            zoneless: this.zoneless,
            config: this.config,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxPinch, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.3", type: NgxPinch, isStandalone: true, selector: "[ngxPinch]", inputs: { _config: ["ngxPinchConfig", "_config"], zoneless: ["ngxPinchZoneless", "zoneless"] }, outputs: { ngxPinch: "ngxPinch" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxPinch, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngxPinch]',
                    standalone: true,
                }]
        }], propDecorators: { _config: [{
                type: Input,
                args: ['ngxPinchConfig']
            }], zoneless: [{
                type: Input,
                args: ['ngxPinchZoneless']
            }], ngxPinch: [{
                type: Output
            }] } });

const injectScroll = createGesture('scroll', ScrollGesture);
class NgxScroll {
    constructor() {
        this.config = signal({});
        this.ngxScroll = new EventEmitter();
        this.injector = inject(Injector);
    }
    set _config(config) {
        this.config.set(config);
    }
    ngOnInit() {
        injectScroll(this.ngxScroll.emit.bind(this.ngxScroll), {
            injector: this.injector,
            zoneless: this.zoneless,
            config: this.config,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxScroll, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.3", type: NgxScroll, isStandalone: true, selector: "[ngxScroll]", inputs: { _config: ["ngxScrollConfig", "_config"], zoneless: ["ngxScrollZoneless", "zoneless"] }, outputs: { ngxScroll: "ngxScroll" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxScroll, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngxScroll]',
                    standalone: true,
                }]
        }], propDecorators: { _config: [{
                type: Input,
                args: ['ngxScrollConfig']
            }], zoneless: [{
                type: Input,
                args: ['ngxScrollZoneless']
            }], ngxScroll: [{
                type: Output
            }] } });

const injectWheel = createGesture('wheel', WheelGesture);
class NgxWheel {
    constructor() {
        this.config = signal({});
        this.ngxWheel = new EventEmitter();
        this.injector = inject(Injector);
    }
    set _config(config) {
        this.config.set(config);
    }
    ngOnInit() {
        injectWheel(this.ngxWheel.emit.bind(this.ngxWheel), {
            injector: this.injector,
            zoneless: this.zoneless,
            config: this.config,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxWheel, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.3", type: NgxWheel, isStandalone: true, selector: "[ngxWheel]", inputs: { _config: ["ngxWheelConfig", "_config"], zoneless: ["ngxWheelZoneless", "zoneless"] }, outputs: { ngxWheel: "ngxWheel" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxWheel, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngxWheel]',
                    standalone: true,
                }]
        }], propDecorators: { _config: [{
                type: Input,
                args: ['ngxWheelConfig']
            }], zoneless: [{
                type: Input,
                args: ['ngxWheelZoneless']
            }], ngxWheel: [{
                type: Output
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { NgxDrag, NgxHover, NgxMove, NgxPinch, NgxScroll, NgxWheel, injectDrag, injectHover, injectMove, injectPinch, injectScroll, injectWheel, injectZonelessGesture, provideZonelessGesture };
