import * as i0 from '@angular/core';
import { Directive, InjectionToken, inject, Injectable, ComponentFactoryResolver, ApplicationRef, SecurityContext, Injector, Inject, signal, Component, ChangeDetectionStrategy, HostBinding, HostListener, makeEnvironmentProviders, NgModule } from '@angular/core';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { DOCUMENT, NgIf } from '@angular/common';
import { Subject } from 'rxjs';
import * as i2 from '@angular/platform-browser';
const _c0 = ["toast-component", ""];
function Toast_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 5);
    i0.ɵɵlistener("click", function Toast_button_0_Template_button_click_0_listener() {
      i0.ɵɵrestoreView(_r1);
      const ctx_r1 = i0.ɵɵnextContext();
      return i0.ɵɵresetView(ctx_r1.remove());
    });
    i0.ɵɵelementStart(1, "span", 6);
    i0.ɵɵtext(2, "\xD7");
    i0.ɵɵelementEnd()();
  }
}
function Toast_div_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate1("[", ctx_r1.duplicatesCount + 1, "]");
  }
}
function Toast_div_1_Template(rf, ctx) {
  if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1);
    i0.ɵɵtemplate(2, Toast_div_1_ng_container_2_Template, 2, 1, "ng-container", 4);
    i0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵclassMap(ctx_r1.options.titleClass);
    i0.ɵɵattribute("aria-label", ctx_r1.title);
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate1(" ", ctx_r1.title, " ");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.duplicatesCount);
  }
}
function Toast_div_2_Template(rf, ctx) {
  if (rf & 1) {
    i0.ɵɵelement(0, "div", 7);
  }
  if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵclassMap(ctx_r1.options.messageClass);
    i0.ɵɵproperty("innerHTML", ctx_r1.message, i0.ɵɵsanitizeHtml);
  }
}
function Toast_div_3_Template(rf, ctx) {
  if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 8);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵclassMap(ctx_r1.options.messageClass);
    i0.ɵɵattribute("aria-label", ctx_r1.message);
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate1(" ", ctx_r1.message, " ");
  }
}
function Toast_div_4_Template(rf, ctx) {
  if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵelement(1, "div", 9);
    i0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵstyleProp("width", ctx_r1.width() + "%");
  }
}
function ToastNoAnimation_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 5);
    i0.ɵɵlistener("click", function ToastNoAnimation_button_0_Template_button_click_0_listener() {
      i0.ɵɵrestoreView(_r1);
      const ctx_r1 = i0.ɵɵnextContext();
      return i0.ɵɵresetView(ctx_r1.remove());
    });
    i0.ɵɵelementStart(1, "span", 6);
    i0.ɵɵtext(2, "\xD7");
    i0.ɵɵelementEnd()();
  }
}
function ToastNoAnimation_div_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate1("[", ctx_r1.duplicatesCount + 1, "]");
  }
}
function ToastNoAnimation_div_1_Template(rf, ctx) {
  if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1);
    i0.ɵɵtemplate(2, ToastNoAnimation_div_1_ng_container_2_Template, 2, 1, "ng-container", 4);
    i0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵclassMap(ctx_r1.options.titleClass);
    i0.ɵɵattribute("aria-label", ctx_r1.title);
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate1(" ", ctx_r1.title, " ");
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", ctx_r1.duplicatesCount);
  }
}
function ToastNoAnimation_div_2_Template(rf, ctx) {
  if (rf & 1) {
    i0.ɵɵelement(0, "div", 7);
  }
  if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵclassMap(ctx_r1.options.messageClass);
    i0.ɵɵproperty("innerHTML", ctx_r1.message, i0.ɵɵsanitizeHtml);
  }
}
function ToastNoAnimation_div_3_Template(rf, ctx) {
  if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 8);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵclassMap(ctx_r1.options.messageClass);
    i0.ɵɵattribute("aria-label", ctx_r1.message);
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate1(" ", ctx_r1.message, " ");
  }
}
function ToastNoAnimation_div_4_Template(rf, ctx) {
  if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵelement(1, "div", 9);
    i0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵstyleProp("width", ctx_r1.width() + "%");
  }
}
let ToastContainerDirective = /*#__PURE__*/(() => {
  class ToastContainerDirective {
    el;
    constructor(el) {
      this.el = el;
    }
    getContainerElement() {
      return this.el.nativeElement;
    }
    static ɵfac = function ToastContainerDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || ToastContainerDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));
    };
    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({
      type: ToastContainerDirective,
      selectors: [["", "toastContainer", ""]],
      exportAs: ["toastContainer"]
    });
  }
  return ToastContainerDirective;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
 */
class ComponentPortal {
  _attachedHost;
  /** The type of the component that will be instantiated for attachment. */
  component;
  /**
   * [Optional] Where the attached component should live in Angular's *logical* component tree.
   * This is different from where the component *renders*, which is determined by the PortalHost.
   * The origin necessary when the host is outside of the Angular application context.
   */
  viewContainerRef;
  /** Injector used for the instantiation of the component. */
  injector;
  constructor(component, injector) {
    this.component = component;
    this.injector = injector;
  }
  /** Attach this portal to a host. */
  attach(host, newestOnTop) {
    this._attachedHost = host;
    return host.attach(this, newestOnTop);
  }
  /** Detach this portal from its host */
  detach() {
    const host = this._attachedHost;
    if (host) {
      this._attachedHost = undefined;
      return host.detach();
    }
  }
  /** Whether this portal is attached to a host. */
  get isAttached() {
    return this._attachedHost != null;
  }
  /**
   * Sets the PortalHost reference without performing `attach()`. This is used directly by
   * the PortalHost when it is performing an `attach()` or `detach()`.
   */
  setAttachedHost(host) {
    this._attachedHost = host;
  }
}
/**
 * Partial implementation of PortalHost that only deals with attaching a
 * ComponentPortal
 */
class BasePortalHost {
  /** The portal currently attached to the host. */
  _attachedPortal;
  /** A function that will permanently dispose this host. */
  _disposeFn;
  attach(portal, newestOnTop) {
    this._attachedPortal = portal;
    return this.attachComponentPortal(portal, newestOnTop);
  }
  detach() {
    if (this._attachedPortal) {
      this._attachedPortal.setAttachedHost();
    }
    this._attachedPortal = undefined;
    if (this._disposeFn) {
      this._disposeFn();
      this._disposeFn = undefined;
    }
  }
  setDisposeFn(fn) {
    this._disposeFn = fn;
  }
}

/**
 * Reference to a toast opened via the Toastr service.
 */
class ToastRef {
  _overlayRef;
  /** The instance of component opened into the toast. */
  componentInstance;
  /** Count of duplicates of this toast */
  duplicatesCount = 0;
  /** Subject for notifying the user that the toast has finished closing. */
  _afterClosed = new Subject();
  /** triggered when toast is activated */
  _activate = new Subject();
  /** notifies the toast that it should close before the timeout */
  _manualClose = new Subject();
  /** notifies the toast that it should reset the timeouts */
  _resetTimeout = new Subject();
  /** notifies the toast that it should count a duplicate toast */
  _countDuplicate = new Subject();
  constructor(_overlayRef) {
    this._overlayRef = _overlayRef;
  }
  manualClose() {
    this._manualClose.next();
    this._manualClose.complete();
  }
  manualClosed() {
    return this._manualClose.asObservable();
  }
  timeoutReset() {
    return this._resetTimeout.asObservable();
  }
  countDuplicate() {
    return this._countDuplicate.asObservable();
  }
  /**
   * Close the toast.
   */
  close() {
    this._overlayRef.detach();
    this._afterClosed.next();
    this._manualClose.next();
    this._afterClosed.complete();
    this._manualClose.complete();
    this._activate.complete();
    this._resetTimeout.complete();
    this._countDuplicate.complete();
  }
  /** Gets an observable that is notified when the toast is finished closing. */
  afterClosed() {
    return this._afterClosed.asObservable();
  }
  isInactive() {
    return this._activate.isStopped;
  }
  activate() {
    this._activate.next();
    this._activate.complete();
  }
  /** Gets an observable that is notified when the toast has started opening. */
  afterActivate() {
    return this._activate.asObservable();
  }
  /** Reset the toast timouts and count duplicates */
  onDuplicate(resetTimeout, countDuplicate) {
    if (resetTimeout) {
      this._resetTimeout.next();
    }
    if (countDuplicate) {
      this._countDuplicate.next(++this.duplicatesCount);
    }
  }
}

/**
 * Everything a toast needs to launch
 */
class ToastPackage {
  toastId;
  config;
  message;
  title;
  toastType;
  toastRef;
  _onTap = new Subject();
  _onAction = new Subject();
  constructor(toastId, config, message, title, toastType, toastRef) {
    this.toastId = toastId;
    this.config = config;
    this.message = message;
    this.title = title;
    this.toastType = toastType;
    this.toastRef = toastRef;
    this.toastRef.afterClosed().subscribe(() => {
      this._onAction.complete();
      this._onTap.complete();
    });
  }
  /** Fired on click */
  triggerTap() {
    this._onTap.next();
    if (this.config.tapToDismiss) {
      this._onTap.complete();
    }
  }
  onTap() {
    return this._onTap.asObservable();
  }
  /** available for use in custom toast */
  triggerAction(action) {
    this._onAction.next(action);
  }
  onAction() {
    return this._onAction.asObservable();
  }
}
const DefaultNoComponentGlobalConfig = {
  maxOpened: 0,
  autoDismiss: false,
  newestOnTop: true,
  preventDuplicates: false,
  countDuplicates: false,
  resetTimeoutOnDuplicate: false,
  includeTitleDuplicates: false,
  iconClasses: {
    error: 'toast-error',
    info: 'toast-info',
    success: 'toast-success',
    warning: 'toast-warning'
  },
  // Individual
  closeButton: false,
  disableTimeOut: false,
  timeOut: 5000,
  extendedTimeOut: 1000,
  enableHtml: false,
  progressBar: false,
  toastClass: 'ngx-toastr',
  positionClass: 'toast-top-right',
  titleClass: 'toast-title',
  messageClass: 'toast-message',
  easing: 'ease-in',
  easeTime: 300,
  tapToDismiss: true,
  onActivateTick: false,
  progressAnimation: 'decreasing'
};
const TOAST_CONFIG = new InjectionToken('ToastConfig');

/**
 * A PortalHost for attaching portals to an arbitrary DOM element outside of the Angular
 * application context.
 *
 * This is the only part of the portal core that directly touches the DOM.
 */
class DomPortalHost extends BasePortalHost {
  _hostDomElement;
  _componentFactoryResolver;
  _appRef;
  constructor(_hostDomElement, _componentFactoryResolver, _appRef) {
    super();
    this._hostDomElement = _hostDomElement;
    this._componentFactoryResolver = _componentFactoryResolver;
    this._appRef = _appRef;
  }
  /**
   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
   * @param portal Portal to be attached
   */
  attachComponentPortal(portal, newestOnTop) {
    const componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);
    let componentRef;
    // If the portal specifies a ViewContainerRef, we will use that as the attachment point
    // for the component (in terms of Angular's component tree, not rendering).
    // When the ViewContainerRef is missing, we use the factory to create the component directly
    // and then manually attach the ChangeDetector for that component to the application (which
    // happens automatically when using a ViewContainer).
    componentRef = componentFactory.create(portal.injector);
    // When creating a component outside of a ViewContainer, we need to manually register
    // its ChangeDetector with the application. This API is unfortunately not yet published
    // in Angular core. The change detector must also be deregistered when the component
    // is destroyed to prevent memory leaks.
    this._appRef.attachView(componentRef.hostView);
    this.setDisposeFn(() => {
      this._appRef.detachView(componentRef.hostView);
      componentRef.destroy();
    });
    // At this point the component has been instantiated, so we move it to the location in the DOM
    // where we want it to be rendered.
    if (newestOnTop) {
      this._hostDomElement.insertBefore(this._getComponentRootNode(componentRef), this._hostDomElement.firstChild);
    } else {
      this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));
    }
    return componentRef;
  }
  /** Gets the root HTMLElement for an instantiated component. */
  _getComponentRootNode(componentRef) {
    return componentRef.hostView.rootNodes[0];
  }
}

/** Container inside which all toasts will render. */
let OverlayContainer = /*#__PURE__*/(() => {
  class OverlayContainer {
    _document = inject(DOCUMENT);
    _containerElement;
    ngOnDestroy() {
      if (this._containerElement && this._containerElement.parentNode) {
        this._containerElement.parentNode.removeChild(this._containerElement);
      }
    }
    /**
     * This method returns the overlay container element. It will lazily
     * create the element the first time  it is called to facilitate using
     * the container in non-browser environments.
     * @returns the container element
     */
    getContainerElement() {
      if (!this._containerElement) {
        this._createContainer();
      }
      return this._containerElement;
    }
    /**
     * Create the overlay container element, which is simply a div
     * with the 'cdk-overlay-container' class on the document body
     * and 'aria-live="polite"'
     */
    _createContainer() {
      const container = this._document.createElement('div');
      container.classList.add('overlay-container');
      container.setAttribute('aria-live', 'polite');
      this._document.body.appendChild(container);
      this._containerElement = container;
    }
    static ɵfac = function OverlayContainer_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || OverlayContainer)();
    };
    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({
      token: OverlayContainer,
      factory: OverlayContainer.ɵfac,
      providedIn: 'root'
    });
  }
  return OverlayContainer;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * Reference to an overlay that has been created with the Overlay service.
 * Used to manipulate or dispose of said overlay.
 */
class OverlayRef {
  _portalHost;
  constructor(_portalHost) {
    this._portalHost = _portalHost;
  }
  attach(portal, newestOnTop = true) {
    return this._portalHost.attach(portal, newestOnTop);
  }
  /**
   * Detaches an overlay from a portal.
   * @returns Resolves when the overlay has been detached.
   */
  detach() {
    return this._portalHost.detach();
  }
}

/**
 * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be
 * used as a low-level building building block for other components. Dialogs, tooltips, menus,
 * selects, etc. can all be built using overlays. The service should primarily be used by authors
 * of re-usable components rather than developers building end-user applications.
 *
 * An overlay *is* a PortalHost, so any kind of Portal can be loaded into one.
 */
let Overlay = /*#__PURE__*/(() => {
  class Overlay {
    _overlayContainer = inject(OverlayContainer);
    _componentFactoryResolver = inject(ComponentFactoryResolver);
    _appRef = inject(ApplicationRef);
    _document = inject(DOCUMENT);
    // Namespace panes by overlay container
    _paneElements = new Map();
    /**
     * Creates an overlay.
     * @returns A reference to the created overlay.
     */
    create(positionClass, overlayContainer) {
      // get existing pane if possible
      return this._createOverlayRef(this.getPaneElement(positionClass, overlayContainer));
    }
    getPaneElement(positionClass = '', overlayContainer) {
      if (!this._paneElements.get(overlayContainer)) {
        this._paneElements.set(overlayContainer, {});
      }
      if (!this._paneElements.get(overlayContainer)[positionClass]) {
        this._paneElements.get(overlayContainer)[positionClass] = this._createPaneElement(positionClass, overlayContainer);
      }
      return this._paneElements.get(overlayContainer)[positionClass];
    }
    /**
     * Creates the DOM element for an overlay and appends it to the overlay container.
     * @returns Newly-created pane element
     */
    _createPaneElement(positionClass, overlayContainer) {
      const pane = this._document.createElement('div');
      pane.id = 'toast-container';
      pane.classList.add(positionClass);
      pane.classList.add('toast-container');
      if (!overlayContainer) {
        this._overlayContainer.getContainerElement().appendChild(pane);
      } else {
        overlayContainer.getContainerElement().appendChild(pane);
      }
      return pane;
    }
    /**
     * Create a DomPortalHost into which the overlay content can be loaded.
     * @param pane The DOM element to turn into a portal host.
     * @returns A portal host for the given DOM element.
     */
    _createPortalHost(pane) {
      return new DomPortalHost(pane, this._componentFactoryResolver, this._appRef);
    }
    /**
     * Creates an OverlayRef for an overlay in the given DOM element.
     * @param pane DOM element for the overlay
     */
    _createOverlayRef(pane) {
      return new OverlayRef(this._createPortalHost(pane));
    }
    static ɵfac = function Overlay_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || Overlay)();
    };
    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({
      token: Overlay,
      factory: Overlay.ɵfac,
      providedIn: 'root'
    });
  }
  return Overlay;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
let ToastrService = /*#__PURE__*/(() => {
  class ToastrService {
    overlay;
    _injector;
    sanitizer;
    ngZone;
    toastrConfig;
    currentlyActive = 0;
    toasts = [];
    overlayContainer;
    previousToastMessage;
    index = 0;
    constructor(token, overlay, _injector, sanitizer, ngZone) {
      this.overlay = overlay;
      this._injector = _injector;
      this.sanitizer = sanitizer;
      this.ngZone = ngZone;
      this.toastrConfig = {
        ...token.default,
        ...token.config
      };
      if (token.config.iconClasses) {
        this.toastrConfig.iconClasses = {
          ...token.default.iconClasses,
          ...token.config.iconClasses
        };
      }
    }
    /** show toast */
    show(message, title, override = {}, type = '') {
      return this._preBuildNotification(type, message, title, this.applyConfig(override));
    }
    /** show successful toast */
    success(message, title, override = {}) {
      const type = this.toastrConfig.iconClasses.success || '';
      return this._preBuildNotification(type, message, title, this.applyConfig(override));
    }
    /** show error toast */
    error(message, title, override = {}) {
      const type = this.toastrConfig.iconClasses.error || '';
      return this._preBuildNotification(type, message, title, this.applyConfig(override));
    }
    /** show info toast */
    info(message, title, override = {}) {
      const type = this.toastrConfig.iconClasses.info || '';
      return this._preBuildNotification(type, message, title, this.applyConfig(override));
    }
    /** show warning toast */
    warning(message, title, override = {}) {
      const type = this.toastrConfig.iconClasses.warning || '';
      return this._preBuildNotification(type, message, title, this.applyConfig(override));
    }
    /**
     * Remove all or a single toast by id
     */
    clear(toastId) {
      // Call every toastRef manualClose function
      for (const toast of this.toasts) {
        if (toastId !== undefined) {
          if (toast.toastId === toastId) {
            toast.toastRef.manualClose();
            return;
          }
        } else {
          toast.toastRef.manualClose();
        }
      }
    }
    /**
     * Remove and destroy a single toast by id
     */
    remove(toastId) {
      const found = this._findToast(toastId);
      if (!found) {
        return false;
      }
      found.activeToast.toastRef.close();
      this.toasts.splice(found.index, 1);
      this.currentlyActive = this.currentlyActive - 1;
      if (!this.toastrConfig.maxOpened || !this.toasts.length) {
        return false;
      }
      if (this.currentlyActive < this.toastrConfig.maxOpened && this.toasts[this.currentlyActive]) {
        const p = this.toasts[this.currentlyActive].toastRef;
        if (!p.isInactive()) {
          this.currentlyActive = this.currentlyActive + 1;
          p.activate();
        }
      }
      return true;
    }
    /**
     * Determines if toast message is already shown
     */
    findDuplicate(title = '', message = '', resetOnDuplicate, countDuplicates) {
      const {
        includeTitleDuplicates
      } = this.toastrConfig;
      for (const toast of this.toasts) {
        const hasDuplicateTitle = includeTitleDuplicates && toast.title === title;
        if ((!includeTitleDuplicates || hasDuplicateTitle) && toast.message === message) {
          toast.toastRef.onDuplicate(resetOnDuplicate, countDuplicates);
          return toast;
        }
      }
      return null;
    }
    /** create a clone of global config and apply individual settings */
    applyConfig(override = {}) {
      return {
        ...this.toastrConfig,
        ...override
      };
    }
    /**
     * Find toast object by id
     */
    _findToast(toastId) {
      for (let i = 0; i < this.toasts.length; i++) {
        if (this.toasts[i].toastId === toastId) {
          return {
            index: i,
            activeToast: this.toasts[i]
          };
        }
      }
      return null;
    }
    /**
     * Determines the need to run inside angular's zone then builds the toast
     */
    _preBuildNotification(toastType, message, title, config) {
      if (config.onActivateTick) {
        return this.ngZone.run(() => this._buildNotification(toastType, message, title, config));
      }
      return this._buildNotification(toastType, message, title, config);
    }
    /**
     * Creates and attaches toast data to component
     * returns the active toast, or in case preventDuplicates is enabled the original/non-duplicate active toast.
     */
    _buildNotification(toastType, message, title, config) {
      if (!config.toastComponent) {
        throw new Error('toastComponent required');
      }
      // max opened and auto dismiss = true
      // if timeout = 0 resetting it would result in setting this.hideTime = Date.now(). Hence, we only want to reset timeout if there is
      // a timeout at all
      const duplicate = this.findDuplicate(title, message, this.toastrConfig.resetTimeoutOnDuplicate && config.timeOut > 0, this.toastrConfig.countDuplicates);
      if ((this.toastrConfig.includeTitleDuplicates && title || message) && this.toastrConfig.preventDuplicates && duplicate !== null) {
        return duplicate;
      }
      this.previousToastMessage = message;
      let keepInactive = false;
      if (this.toastrConfig.maxOpened && this.currentlyActive >= this.toastrConfig.maxOpened) {
        keepInactive = true;
        if (this.toastrConfig.autoDismiss) {
          this.clear(this.toasts[0].toastId);
        }
      }
      const overlayRef = this.overlay.create(config.positionClass, this.overlayContainer);
      this.index = this.index + 1;
      let sanitizedMessage = message;
      if (message && config.enableHtml) {
        sanitizedMessage = this.sanitizer.sanitize(SecurityContext.HTML, message);
      }
      const toastRef = new ToastRef(overlayRef);
      const toastPackage = new ToastPackage(this.index, config, sanitizedMessage, title, toastType, toastRef);
      /** New injector that contains an instance of `ToastPackage`. */
      const providers = [{
        provide: ToastPackage,
        useValue: toastPackage
      }];
      const toastInjector = Injector.create({
        providers,
        parent: this._injector
      });
      const component = new ComponentPortal(config.toastComponent, toastInjector);
      const portal = overlayRef.attach(component, config.newestOnTop);
      toastRef.componentInstance = portal.instance;
      const ins = {
        toastId: this.index,
        title: title || '',
        message: message || '',
        toastRef,
        onShown: toastRef.afterActivate(),
        onHidden: toastRef.afterClosed(),
        onTap: toastPackage.onTap(),
        onAction: toastPackage.onAction(),
        portal
      };
      if (!keepInactive) {
        this.currentlyActive = this.currentlyActive + 1;
        setTimeout(() => {
          ins.toastRef.activate();
        });
      }
      this.toasts.push(ins);
      return ins;
    }
    static ɵfac = function ToastrService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || ToastrService)(i0.ɵɵinject(TOAST_CONFIG), i0.ɵɵinject(Overlay), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i2.DomSanitizer), i0.ɵɵinject(i0.NgZone));
    };
    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({
      token: ToastrService,
      factory: ToastrService.ɵfac,
      providedIn: 'root'
    });
  }
  return ToastrService;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
let Toast = /*#__PURE__*/(() => {
  class Toast {
    toastrService;
    toastPackage;
    ngZone;
    message;
    title;
    options;
    duplicatesCount;
    originalTimeout;
    /** width of progress bar */
    width = signal(-1);
    /** a combination of toast type and options.toastClass */
    toastClasses = '';
    state;
    /** controls animation */
    get _state() {
      return this.state();
    }
    /** hides component when waiting to be displayed */
    get displayStyle() {
      if (this.state().value === 'inactive') {
        return 'none';
      }
      return;
    }
    timeout;
    intervalId;
    hideTime;
    sub;
    sub1;
    sub2;
    sub3;
    constructor(toastrService, toastPackage, ngZone) {
      this.toastrService = toastrService;
      this.toastPackage = toastPackage;
      this.ngZone = ngZone;
      this.message = toastPackage.message;
      this.title = toastPackage.title;
      this.options = toastPackage.config;
      this.originalTimeout = toastPackage.config.timeOut;
      this.toastClasses = `${toastPackage.toastType} ${toastPackage.config.toastClass}`;
      this.sub = toastPackage.toastRef.afterActivate().subscribe(() => {
        this.activateToast();
      });
      this.sub1 = toastPackage.toastRef.manualClosed().subscribe(() => {
        this.remove();
      });
      this.sub2 = toastPackage.toastRef.timeoutReset().subscribe(() => {
        this.resetTimeout();
      });
      this.sub3 = toastPackage.toastRef.countDuplicate().subscribe(count => {
        this.duplicatesCount = count;
      });
      this.state = signal({
        value: 'inactive',
        params: {
          easeTime: this.toastPackage.config.easeTime,
          easing: 'ease-in'
        }
      });
    }
    ngOnDestroy() {
      this.sub.unsubscribe();
      this.sub1.unsubscribe();
      this.sub2.unsubscribe();
      this.sub3.unsubscribe();
      clearInterval(this.intervalId);
      clearTimeout(this.timeout);
    }
    /**
     * activates toast and sets timeout
     */
    activateToast() {
      this.state.update(state => ({
        ...state,
        value: 'active'
      }));
      if (!(this.options.disableTimeOut === true || this.options.disableTimeOut === 'timeOut') && this.options.timeOut) {
        this.outsideTimeout(() => this.remove(), this.options.timeOut);
        this.hideTime = new Date().getTime() + this.options.timeOut;
        if (this.options.progressBar) {
          this.outsideInterval(() => this.updateProgress(), 10);
        }
      }
    }
    /**
     * updates progress bar width
     */
    updateProgress() {
      if (this.width() === 0 || this.width() === 100 || !this.options.timeOut) {
        return;
      }
      const now = new Date().getTime();
      const remaining = this.hideTime - now;
      this.width.set(remaining / this.options.timeOut * 100);
      if (this.options.progressAnimation === 'increasing') {
        this.width.update(width => 100 - width);
      }
      if (this.width() <= 0) {
        this.width.set(0);
      }
      if (this.width() >= 100) {
        this.width.set(100);
      }
    }
    resetTimeout() {
      clearTimeout(this.timeout);
      clearInterval(this.intervalId);
      this.state.update(state => ({
        ...state,
        value: 'active'
      }));
      this.outsideTimeout(() => this.remove(), this.originalTimeout);
      this.options.timeOut = this.originalTimeout;
      this.hideTime = new Date().getTime() + (this.options.timeOut || 0);
      this.width.set(-1);
      if (this.options.progressBar) {
        this.outsideInterval(() => this.updateProgress(), 10);
      }
    }
    /**
     * tells toastrService to remove this toast after animation time
     */
    remove() {
      if (this.state().value === 'removed') {
        return;
      }
      clearTimeout(this.timeout);
      this.state.update(state => ({
        ...state,
        value: 'removed'
      }));
      this.outsideTimeout(() => this.toastrService.remove(this.toastPackage.toastId), +this.toastPackage.config.easeTime);
    }
    tapToast() {
      if (this.state().value === 'removed') {
        return;
      }
      this.toastPackage.triggerTap();
      if (this.options.tapToDismiss) {
        this.remove();
      }
    }
    stickAround() {
      if (this.state().value === 'removed') {
        return;
      }
      if (this.options.disableTimeOut !== 'extendedTimeOut') {
        clearTimeout(this.timeout);
        this.options.timeOut = 0;
        this.hideTime = 0;
        // disable progressBar
        clearInterval(this.intervalId);
        this.width.set(0);
      }
    }
    delayedHideToast() {
      if (this.options.disableTimeOut === true || this.options.disableTimeOut === 'extendedTimeOut' || this.options.extendedTimeOut === 0 || this.state().value === 'removed') {
        return;
      }
      this.outsideTimeout(() => this.remove(), this.options.extendedTimeOut);
      this.options.timeOut = this.options.extendedTimeOut;
      this.hideTime = new Date().getTime() + (this.options.timeOut || 0);
      this.width.set(-1);
      if (this.options.progressBar) {
        this.outsideInterval(() => this.updateProgress(), 10);
      }
    }
    outsideTimeout(func, timeout) {
      if (this.ngZone) {
        this.ngZone.runOutsideAngular(() => this.timeout = setTimeout(() => this.runInsideAngular(func), timeout));
      } else {
        this.timeout = setTimeout(() => func(), timeout);
      }
    }
    outsideInterval(func, timeout) {
      if (this.ngZone) {
        this.ngZone.runOutsideAngular(() => this.intervalId = setInterval(() => this.runInsideAngular(func), timeout));
      } else {
        this.intervalId = setInterval(() => func(), timeout);
      }
    }
    runInsideAngular(func) {
      if (this.ngZone) {
        this.ngZone.run(() => func());
      } else {
        func();
      }
    }
    static ɵfac = function Toast_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || Toast)(i0.ɵɵdirectiveInject(ToastrService), i0.ɵɵdirectiveInject(ToastPackage), i0.ɵɵdirectiveInject(i0.NgZone));
    };
    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({
      type: Toast,
      selectors: [["", "toast-component", ""]],
      hostVars: 5,
      hostBindings: function Toast_HostBindings(rf, ctx) {
        if (rf & 1) {
          i0.ɵɵlistener("click", function Toast_click_HostBindingHandler() {
            return ctx.tapToast();
          })("mouseenter", function Toast_mouseenter_HostBindingHandler() {
            return ctx.stickAround();
          })("mouseleave", function Toast_mouseleave_HostBindingHandler() {
            return ctx.delayedHideToast();
          });
        }
        if (rf & 2) {
          i0.ɵɵsyntheticHostProperty("@flyInOut", ctx._state);
          i0.ɵɵclassMap(ctx.toastClasses);
          i0.ɵɵstyleProp("display", ctx.displayStyle);
        }
      },
      attrs: _c0,
      decls: 5,
      vars: 5,
      consts: [["type", "button", "class", "toast-close-button", "aria-label", "Close", 3, "click", 4, "ngIf"], [3, "class", 4, "ngIf"], ["role", "alert", 3, "class", "innerHTML", 4, "ngIf"], ["role", "alert", 3, "class", 4, "ngIf"], [4, "ngIf"], ["type", "button", "aria-label", "Close", 1, "toast-close-button", 3, "click"], ["aria-hidden", "true"], ["role", "alert", 3, "innerHTML"], ["role", "alert"], [1, "toast-progress"]],
      template: function Toast_Template(rf, ctx) {
        if (rf & 1) {
          i0.ɵɵtemplate(0, Toast_button_0_Template, 3, 0, "button", 0)(1, Toast_div_1_Template, 3, 5, "div", 1)(2, Toast_div_2_Template, 1, 3, "div", 2)(3, Toast_div_3_Template, 2, 4, "div", 3)(4, Toast_div_4_Template, 2, 2, "div", 4);
        }
        if (rf & 2) {
          i0.ɵɵproperty("ngIf", ctx.options.closeButton);
          i0.ɵɵadvance();
          i0.ɵɵproperty("ngIf", ctx.title);
          i0.ɵɵadvance();
          i0.ɵɵproperty("ngIf", ctx.message && ctx.options.enableHtml);
          i0.ɵɵadvance();
          i0.ɵɵproperty("ngIf", ctx.message && !ctx.options.enableHtml);
          i0.ɵɵadvance();
          i0.ɵɵproperty("ngIf", ctx.options.progressBar);
        }
      },
      dependencies: [NgIf],
      encapsulation: 2,
      data: {
        animation: [trigger('flyInOut', [state('inactive', style({
          opacity: 0
        })), state('active', style({
          opacity: 1
        })), state('removed', style({
          opacity: 0
        })), transition('inactive => active', animate('{{ easeTime }}ms {{ easing }}')), transition('active => removed', animate('{{ easeTime }}ms {{ easing }}'))])]
      },
      changeDetection: 0
    });
  }
  return Toast;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
const DefaultGlobalConfig = {
  ...DefaultNoComponentGlobalConfig,
  toastComponent: Toast
};
/**
 * @description
 * Provides the `TOAST_CONFIG` token with the given config.
 *
 * @param config The config to configure toastr.
 * @returns The environment providers.
 *
 * @example
 * ```ts
 * import { provideToastr } from 'ngx-toastr';
 *
 * bootstrap(AppComponent, {
 *   providers: [
 *     provideToastr({
 *       timeOut: 2000,
 *       positionClass: 'toast-top-right',
 *     }),
 *   ],
 * })
 */
const provideToastr = (config = {}) => {
  const providers = [{
    provide: TOAST_CONFIG,
    useValue: {
      default: DefaultGlobalConfig,
      config
    }
  }];
  return makeEnvironmentProviders(providers);
};
let ToastrModule = /*#__PURE__*/(() => {
  class ToastrModule {
    static forRoot(config = {}) {
      return {
        ngModule: ToastrModule,
        providers: [provideToastr(config)]
      };
    }
    static ɵfac = function ToastrModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || ToastrModule)();
    };
    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({
      type: ToastrModule
    });
    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});
  }
  return ToastrModule;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
let ToastrComponentlessModule = /*#__PURE__*/(() => {
  class ToastrComponentlessModule {
    static forRoot(config = {}) {
      return {
        ngModule: ToastrModule,
        providers: [{
          provide: TOAST_CONFIG,
          useValue: {
            default: DefaultNoComponentGlobalConfig,
            config
          }
        }]
      };
    }
    static ɵfac = function ToastrComponentlessModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || ToastrComponentlessModule)();
    };
    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({
      type: ToastrComponentlessModule
    });
    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});
  }
  return ToastrComponentlessModule;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
let ToastNoAnimation = /*#__PURE__*/(() => {
  class ToastNoAnimation {
    toastrService;
    toastPackage;
    appRef;
    message;
    title;
    options;
    duplicatesCount;
    originalTimeout;
    /** width of progress bar */
    width = signal(-1);
    /** a combination of toast type and options.toastClass */
    toastClasses = '';
    /** hides component when waiting to be displayed */
    get displayStyle() {
      if (this.state() === 'inactive') {
        return 'none';
      }
      return null;
    }
    /** controls animation */
    state = signal('inactive');
    timeout;
    intervalId;
    hideTime;
    sub;
    sub1;
    sub2;
    sub3;
    constructor(toastrService, toastPackage, appRef) {
      this.toastrService = toastrService;
      this.toastPackage = toastPackage;
      this.appRef = appRef;
      this.message = toastPackage.message;
      this.title = toastPackage.title;
      this.options = toastPackage.config;
      this.originalTimeout = toastPackage.config.timeOut;
      this.toastClasses = `${toastPackage.toastType} ${toastPackage.config.toastClass}`;
      this.sub = toastPackage.toastRef.afterActivate().subscribe(() => {
        this.activateToast();
      });
      this.sub1 = toastPackage.toastRef.manualClosed().subscribe(() => {
        this.remove();
      });
      this.sub2 = toastPackage.toastRef.timeoutReset().subscribe(() => {
        this.resetTimeout();
      });
      this.sub3 = toastPackage.toastRef.countDuplicate().subscribe(count => {
        this.duplicatesCount = count;
      });
    }
    ngOnDestroy() {
      this.sub.unsubscribe();
      this.sub1.unsubscribe();
      this.sub2.unsubscribe();
      this.sub3.unsubscribe();
      clearInterval(this.intervalId);
      clearTimeout(this.timeout);
    }
    /**
     * activates toast and sets timeout
     */
    activateToast() {
      this.state.set('active');
      if (!(this.options.disableTimeOut === true || this.options.disableTimeOut === 'timeOut') && this.options.timeOut) {
        this.timeout = setTimeout(() => {
          this.remove();
        }, this.options.timeOut);
        this.hideTime = new Date().getTime() + this.options.timeOut;
        if (this.options.progressBar) {
          this.intervalId = setInterval(() => this.updateProgress(), 10);
        }
      }
      if (this.options.onActivateTick) {
        this.appRef.tick();
      }
    }
    /**
     * updates progress bar width
     */
    updateProgress() {
      if (this.width() === 0 || this.width() === 100 || !this.options.timeOut) {
        return;
      }
      const now = new Date().getTime();
      const remaining = this.hideTime - now;
      this.width.set(remaining / this.options.timeOut * 100);
      if (this.options.progressAnimation === 'increasing') {
        this.width.update(width => 100 - width);
      }
      if (this.width() <= 0) {
        this.width.set(0);
      }
      if (this.width() >= 100) {
        this.width.set(100);
      }
    }
    resetTimeout() {
      clearTimeout(this.timeout);
      clearInterval(this.intervalId);
      this.state.set('active');
      this.options.timeOut = this.originalTimeout;
      this.timeout = setTimeout(() => this.remove(), this.originalTimeout);
      this.hideTime = new Date().getTime() + (this.originalTimeout || 0);
      this.width.set(-1);
      if (this.options.progressBar) {
        this.intervalId = setInterval(() => this.updateProgress(), 10);
      }
    }
    /**
     * tells toastrService to remove this toast after animation time
     */
    remove() {
      if (this.state() === 'removed') {
        return;
      }
      clearTimeout(this.timeout);
      this.state.set('removed');
      this.timeout = setTimeout(() => this.toastrService.remove(this.toastPackage.toastId));
    }
    tapToast() {
      if (this.state() === 'removed') {
        return;
      }
      this.toastPackage.triggerTap();
      if (this.options.tapToDismiss) {
        this.remove();
      }
    }
    stickAround() {
      if (this.state() === 'removed') {
        return;
      }
      clearTimeout(this.timeout);
      this.options.timeOut = 0;
      this.hideTime = 0;
      // disable progressBar
      clearInterval(this.intervalId);
      this.width.set(0);
    }
    delayedHideToast() {
      if (this.options.disableTimeOut === true || this.options.disableTimeOut === 'extendedTimeOut' || this.options.extendedTimeOut === 0 || this.state() === 'removed') {
        return;
      }
      this.timeout = setTimeout(() => this.remove(), this.options.extendedTimeOut);
      this.options.timeOut = this.options.extendedTimeOut;
      this.hideTime = new Date().getTime() + (this.options.timeOut || 0);
      this.width.set(-1);
      if (this.options.progressBar) {
        this.intervalId = setInterval(() => this.updateProgress(), 10);
      }
    }
    static ɵfac = function ToastNoAnimation_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || ToastNoAnimation)(i0.ɵɵdirectiveInject(ToastrService), i0.ɵɵdirectiveInject(ToastPackage), i0.ɵɵdirectiveInject(i0.ApplicationRef));
    };
    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({
      type: ToastNoAnimation,
      selectors: [["", "toast-component", ""]],
      hostVars: 4,
      hostBindings: function ToastNoAnimation_HostBindings(rf, ctx) {
        if (rf & 1) {
          i0.ɵɵlistener("click", function ToastNoAnimation_click_HostBindingHandler() {
            return ctx.tapToast();
          })("mouseenter", function ToastNoAnimation_mouseenter_HostBindingHandler() {
            return ctx.stickAround();
          })("mouseleave", function ToastNoAnimation_mouseleave_HostBindingHandler() {
            return ctx.delayedHideToast();
          });
        }
        if (rf & 2) {
          i0.ɵɵclassMap(ctx.toastClasses);
          i0.ɵɵstyleProp("display", ctx.displayStyle);
        }
      },
      attrs: _c0,
      decls: 5,
      vars: 5,
      consts: [["type", "button", "class", "toast-close-button", "aria-label", "Close", 3, "click", 4, "ngIf"], [3, "class", 4, "ngIf"], ["role", "alert", 3, "class", "innerHTML", 4, "ngIf"], ["role", "alert", 3, "class", 4, "ngIf"], [4, "ngIf"], ["type", "button", "aria-label", "Close", 1, "toast-close-button", 3, "click"], ["aria-hidden", "true"], ["role", "alert", 3, "innerHTML"], ["role", "alert"], [1, "toast-progress"]],
      template: function ToastNoAnimation_Template(rf, ctx) {
        if (rf & 1) {
          i0.ɵɵtemplate(0, ToastNoAnimation_button_0_Template, 3, 0, "button", 0)(1, ToastNoAnimation_div_1_Template, 3, 5, "div", 1)(2, ToastNoAnimation_div_2_Template, 1, 3, "div", 2)(3, ToastNoAnimation_div_3_Template, 2, 4, "div", 3)(4, ToastNoAnimation_div_4_Template, 2, 2, "div", 4);
        }
        if (rf & 2) {
          i0.ɵɵproperty("ngIf", ctx.options.closeButton);
          i0.ɵɵadvance();
          i0.ɵɵproperty("ngIf", ctx.title);
          i0.ɵɵadvance();
          i0.ɵɵproperty("ngIf", ctx.message && ctx.options.enableHtml);
          i0.ɵɵadvance();
          i0.ɵɵproperty("ngIf", ctx.message && !ctx.options.enableHtml);
          i0.ɵɵadvance();
          i0.ɵɵproperty("ngIf", ctx.options.progressBar);
        }
      },
      dependencies: [NgIf],
      encapsulation: 2,
      changeDetection: 0
    });
  }
  return ToastNoAnimation;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
const DefaultNoAnimationsGlobalConfig = {
  ...DefaultNoComponentGlobalConfig,
  toastComponent: ToastNoAnimation
};
let ToastNoAnimationModule = /*#__PURE__*/(() => {
  class ToastNoAnimationModule {
    static forRoot(config = {}) {
      return {
        ngModule: ToastNoAnimationModule,
        providers: [{
          provide: TOAST_CONFIG,
          useValue: {
            default: DefaultNoAnimationsGlobalConfig,
            config
          }
        }]
      };
    }
    static ɵfac = function ToastNoAnimationModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || ToastNoAnimationModule)();
    };
    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({
      type: ToastNoAnimationModule
    });
    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});
  }
  return ToastNoAnimationModule;
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * Generated bundle index. Do not edit.
 */

export { BasePortalHost, ComponentPortal, DefaultGlobalConfig, DefaultNoAnimationsGlobalConfig, DefaultNoComponentGlobalConfig, Overlay, OverlayContainer, OverlayRef, TOAST_CONFIG, Toast, ToastContainerDirective, ToastNoAnimation, ToastNoAnimationModule, ToastPackage, ToastRef, ToastrComponentlessModule, ToastrModule, ToastrService, provideToastr };
